# C# 의 이해
---
## 언어 스펙
---
### 클래스 
---
- 필드와 메서드로 이루어진 데이터 구조.
  
- 클래스의 인스턴스에 대한 정의를 제공함.
---
### 구조체
---
- 클래스는 상속과 다형성을 지원하여 상속을 받는 클래스의 계층 구조를 기반으로 정교한 동작을 만듬.
  
- 이와 달리 구조체 형식은 데이터 값을 저장하는 더 간단한 형식임.
  
- 기본 형식을 선언할 수 없으며, struct 형식에서 다른 struct 형식을 파생할 수 없다.

- 크기에 상관없이 스택에 할당됨.
---
### 제네릭
---
- C#의 일반화 프로그래밍을 지원하기 위한 기능.
  - 일반화 프로그래밍 : 타입을 파라미터로 전달 받아 해당 타입에 대한 코드를 필요할 떄 생성하는 프로그래밍 방식.
  
- 제네릭을 사용하면 메서드, 클래스, 구조체, 인터페이스를 사용 대상의 정확한 데이터 형식에 맞게 조정 가능.
  
- 기본 형식에서 상속하고 멤버를 재정의할 필요가 없으므로 코드 재사용 가능.
  
- 컴파일 타임에 올바른 데이터 형식이 적용되므로 형식의 안전성을 보장.
  
- 템플릿과의 차이점
  - 논타입 템플릿 매개 변수를 허용하지 않음.
  
  - 명시적 특수화를 지원하지 않음.
  
  - 부분 특수화를 지원하지 않음.
  
  - 타입 파라미터를 제네릭 타입에 대한 부모 클래스로 사용할 수 없음.
  
  - 타입 파라미터에 기본 타입을 지정할 수 없음.
  
  - 제네릭 타입 파라미터는 제네릭이 될 수 없음.
  
  - 제약 조건으로 특정 조건을 충족하는 타입만 타입 인자로 받을 수 있도록 할 수 있음.
---
### 인터페이스
---
- 클래스 및 구조체에서 구현할 수 있는 계약을 정의하며, 형식 간에 공유되는 기능을 선언.
  
- 메서드, 속성, 이벤트, 인덱서등의 컬렉션의 항목들을 포함.
  
- 인터페이스는 해당 인터페이스가 정의하는 멤버의 구현을 정의하지 않고, 인터페이스를 상속받는 클래스나 구조체의 멤버를 지정함.
---
### 가상함수
---
-
---
### 배열
---
-
---
### 리스트
---
-
---
### namespace
---
-
---
### partial
---
-
---
### 객체지향
---
#### 캡슐화 
---
- 데이터와 데이터를 다루는 함수를 같이 작성하는 것.
  - 작성   
    - 절차지향 => 어떤 타입의 객체를 만들기 위해서 하나의 함수를 만들어야한다.   
  
    - 객체지향 => 어떤 객체를 생성하는 생성자라는 특수한 함수를 이용한다.   
  
    - 더 이상 포인터 변수를 작성할 필요가 없고, this 포인터라는 특수 포인터로 대체된다.   
      - this 포인터 : 매개변수가 암시적으로 변환 했을 때, 매개변수의 주소값을 알려주는 포인터. 매개변수의 역할을 하기 때문에 크기가 없음.

  - 사용
    - 절차지향 => 객체를 초기화하기 위한 함수를 호출하고, 첫 번째 인자로 객체의 주소값 필요.
  
    - 객체지향 => 좀 더 직관적인 초기화 가능. 객체를 이용해 함수 호출 가능.
      - 접근한정자 : 객체를 올바르게 사용할 수 있도록 존재. 외부에 공개할 것과 그렇지 않을 것을 구분 지을 수 있다. -> 객체지향에서는 외부접근이 불가능하여 컴파일 오류 (오류를 확인할 수 있다).
        - public : 외부에서 접근 가능.
        - protected : 클래스 내부 및 자식 클래스만 접근 가능.
        - private : 내부에서만 접근 가능.

 - 객체지향 프로그래밍에서 데이터 부분을 필드, 함수를 메소드라고 한다.
---
#### 상속 
---
- **코드를 물려받는 것.** 코드 재사용.
  
- 객체지향에서는 상속을 이용하여 중복을 줄이고, 타입을 더 작은 단위로 모듈화 할 수 있다.
---
#### 추상화
---
- **구현 세부 정보**를 숨기는 **일반적인 인터페이스**를 **정의**하는 행위.
  - 인터페이스 : 서로 다른 부분이 만나고 소통하거나 서로에게 영향을 미치는 영역. 
  
- 구현 세부 사항에 변화가 생겨도 사용하는 방식에는 달라지는 것이 없기 때문에 확장성도 가지게 됨.
  
- 추상화를 잘하면 잘할수록 데이터를 다루기 쉬워짐.

---
#### 다형성 : 여러가지 형태를 가지는 것.
---
- 다형성을 이용하려면 가상함수가 필요함.
  
- 가상 함수를 이용하려면 상위 타입의 포인터를 이용해야함.
  
- **같은 인터페이스** 내에서 **여러가지 형태**를 띌 수 있음.
  
- 때문에, 다형성은 객체지향 프로그래밍의 핵심이라고 할 수 있다.
---
### 지역변수와 전역변수
---
-
---
### delegate와 event
---
-
---
### 유니티와 C#의 관계
---
-
---
## 메모리
---
### 메모리의 구조
---
#### 코드 영역
---
- 실행할 프로그램의 코드가 저장되는 영역.
- 
---
#### 데이터 영역
---
- 프로그램의 전역 변수와 정적 변수가 저장되는 영역.
- 
---
#### 힙 영역
---
- 
---
#### 스택 영역
---
-
---
### 힙 할당 되는 케이스와 아닌 케이스
---
-
---
### 오브젝트 타입에 밸류 타입을 대입하면 생기는 일
---
-
---
### 박싱과 언박싱
---
- 박싱(Boxing)
  - 값 타입을 object 타입 혹은 값 타입에서 구현된 임의의 인터페이스 타입으로 변환하는 프로세스.
  - 박싱이 일어날 땐, object 타입의 새로운 인스턴스를 생성해 값을 힙으로 복사함.
  - 암시적으로 이루어짐.

- 언박싱(Unboxing)
  - 박싱된 인스턴스에서 값 타입을 추출하는 프로세스.
  - 힙에서 스택으로 값이 복사됨.
  - 명시적으로 이루어짐.
  
- 박싱과 언박싱은 많은 계산을 필요로 하므로 이를 피하도록 코드를 작성해야함.
---
### 가비지 컬렉션
---
- C++ 에서는 동적 할당된 메모리를 사용 후 시스템에 돌려줘야 함.

- 이 과정에서 실수가 많이 발생함.  
  - 메모리 누수(Memory Leak) : 메모리 사용이 끝나고, 해제하지 않은 것.
  - 이중 해제 (Double Free) : 이미 해제가 된 메모리를 또 해제하는 것.
  - 섣부른 해제(Premature Free) : 아직 사용이 끝나지 않았음에도 해제하는 것.

- 이런 불편함을 해결하기 위해 메모리를 자동으로 관리하는 기술이 가비지 컬렉션.

- 가비지 컬렉션의 종류
  - 보수적 가비지 컬렉션.
  - 복제 가비지 컬렉션.
  - 분산 가비지 컬렉션.
  - 증분 가비지 컬렉션.
  
- C#은 가비지 컬렉션을 지원.
  - **매니지드 언어** : 가비지 컬렉션을 지원하는 언어.
- 표준 .NET에서 사용하는 방식은 세대별 가비지 컬렉션임.
---
#### 동작 원리
---
- 가비지 컬렉션은 가비지 컬렉터가 더 이상 사용하지 않는 메모리를 재사용함.
  
- But, 어떤 객체가 사용되고, 사용되지 않는지 판별할 수 있는 알고리즘은 없음.
  
- 따라서, 다음과 같은 방법으로 객체의 사용 여부를 가정함.
  - **추적 가비지 컬렉션**
    - 도달 가능성으로 생존을 가정.
    - 루트를 사용하여 해당 메모리까지 도달하지 못하면 가비지로 가정함.

  - **참조 카운팅**
    - 해당 메모리에 참조하는 것이 없을 때 가비지로 가정.
    - **순환 참조**를 주의해야함.
      - 서로 다른 두 메모리가 서로를 참조하는 것.
      - 이를 방지하기 위해 **약한 참조**라는 개념 사용
        - 가비지 판단 기준인 참조 횟수에는 영향을 주지 않고 참조함.
---
### 세대별 가비지 컬렉션
---
- 매니지드 힙(Managed Heap) : 가비지 컬렉터가 관리하는 메모리.

- 이 힙을 0, 1, 2 세대로 나눠서 관리함 -> 메모리를 재사용하기 용이하기 때문.
  - 파편화 방지를 위해 메모리를 압축함 -> 힙 전체를 하기 보단 일부분에서만 수행하는 것이 빠름.
  
  - 최근에 만들어진 객체일수록 수명이 짧고, 오래된 객체일수록 수명이 길어 재사용할 메모리를 빠르게 분류할 수 있음.

  - 메모리 할당은 0세대에서만 일어남. 최근에 만들어진 객체끼리 서로 연관되는 경향이 있어 캐싱측면에서 용이.
---
### LOH
---
- 개체의 크기가 85KiB보다 크거나 같으면 큰 개체로 간주함.
- 큰 개체의 할당 요청이 있으면 런타임에서 이를 LOH에 할당함.
- 
---
## 최신 기능
---
### 패턴 매칭
---
- 임의의 객체가 특정 패턴을 만족하는지 조사하는 것.
  - Type Pattern Matching
    - '객체' is '타입'.
    - 타입을 조사하는 것 뿐만 아니라, 객체에 있는 값에 접근하기 위해 타입 캐스팅을 사용.
    - C# 7.0 부터 '객체' is '타입' '변수'를 통해 타입 캐스팅없이 바로 캐스팅 된 변수를 사용할 수 있다.
  - var Pattern Matching
    - 다른 타입은 true와 false를 판별할 수 있지만, var은 항상 true를 반환함.
  - const Pattern Matchin
  - Switch Expression
---
### Nullable
---
-
---
# 유니티에 대한 이해
---
## 기능
---
### 코루틴
---
- 실행을 일시정지하고 값을 반환한 후, 중단 지점부터 다음 프레임을 계속 할 수 있는 메서드.
- 시간의 흐름에 따른 이벤트의 시퀀스, 애니메이션이 필요한 상황에 사용 가능하며, 작업을 다수의 프레임에 분산시킬 수 있다.
- 코루틴은 메인 스레드에서 작업이 진행되므로, 연산에 소요되는 시간을 줄이기 위해서는 코루틴의 작업 차단을 방지해야함.
---
### 게임루프와 델타 타임에 대한 이해
---
-
---
### CLR과 유니티 Mono
---
-
---
### Mono와 IL2CPP
---
-
---
### Unity 이벤트 함수
---
#### Awake() - 첫 번째 씬 로드
---
- Start() 함수 전에 호출되며, 프리팹이 인스턴스화 된 직후에 호출됨.
- 게임 오브젝트가 시작하는 동안 비활성 상태인 경우, Awake() 함수는 활성화될 때까지 호출되지 않음.
---
#### OnEnable()
---
- 오브젝트 활성화 직후, 이 함수를 호출하며, 오브젝트가 활성화되지 않았을 경우 호출되지 않음.
- 게임 오브젝트가 MonoBehaviour를 생성할 때 호출. ex) 레벨 로드, 게임 오브젝트가 인스턴스화 될 때.
---
#### Start() - 첫 번째 프레임 업데이트 전
---
- 스크립트 인스턴스가 활성화 되었을 때 호출.
- 씬에 포함된 모든 오브젝트의 Update 이전에 스크립트를 위한 Start()함수가 호출됨.
---
#### FixedUpdate - 업데이트
---
- Update() 보다 자주 호출될 수도 있음.
- 프레임 속도가 낮은 경우 프레임당 여러 번 호출될 수 있음. <-> 프레임 속도가 높은 경우 프레임 사이에 호출되지 않을 수 있음.
- 모든 물리 계산 및 업데이트는 FixedUpdate 이후 즉시 발생함.
- 프레임 속도와 관계없이 신뢰할 수 있는 타이머에서 호출되므로, Time.deltaTime을 곱할 필요가 없음.
---
#### Update()
---
- 프레임당 한번 호출됨.
- 프레임 업데이트를 위한 주요 함수.
---
#### LateUpdate()
---
- Update()가 끝난 후 한 번 호출됨.
- Update()의 모든 연산은 LateUpdate()의 시작 시점에 완료됨.
---
#### OnDisable()
---
- 동작이 비활성화되거나 오브젝트가 비활성 상태일 때 호출됨.
---
#### OnDistroy()
---
- 오브젝트의 마지막 프레임 업데이트를 마치고 호출됨.
- 또는 Object.Destroy, 씬 종료 등으로 파괴될 수 있음.
---
## 최적화
---
### Static GameObject
---
- 런타임 시점에서 움직이지 않는 게임 오브젝트.
- 에디터에서 Static GameObject에 대한 정보를 미리 계산 할 수 있음.
- 움직이지 않기 때문에, 미리 계산된 정보는 유효함.
- 따라서, Static GameObject는 런타임의 연산을 줄이고, 잠재적으로 성능을 향상 시킬 수 있음을 의미.
- **Static Batching**
  - 드로우 콜을 줄이기 위해서 움직이지 않는 메시를 결합.
  - 결합된 메시를 월드 공간으로 변환시킨 후, 메시를 위한 공용 버텍스와 인덱스 버퍼를 빌드함.
  - 정적 배칭은 드로우 콜 사이의 렌더 상태 수를 줄임.
  - CPU에서 버텍스를 변환하지 않으므로 동적 배칭보다 효율적.
---
### 유니티의 가비지 컬렉션
---
-
---
### 드로우 콜 최적화
---
- 드로우 콜 : Unity 그래픽스 API가 렌더링 할 내용과 렌더링 방법을 GPU에 알려주는 것.
- 텍스처,셰이더,버퍼에 대한 정보등 렌더링 할 모든 정보가 포함되어 있음.
- **Dynamic Batching**
  - 
---
### 렌더링 파이프라인 (큐브 하나를 게임뷰에 그리기 위해 유니티 코어 로직에서 일어나는 일)
---
-
---
## 경험
---
### String Concat 루프 대책
---
-
---
### 최적화 전략 수립 과정
---
-
---
### 코루틴과 비동기에 대하여
---
-
---
### 스크립트 실행 순서
---
-
---
### Fake Null에 대해
---
-
---
### Dictionary의 Key로 Enum 사용 (버전 별 상이)
---
-
---
### 스레드, 유니티 메인 스레드
---
-
---
# 펀더멘탈
---
### 프로세스와 스레드
---
-
---
### API란?
---
-
---
### 값 형식과 참조 형식
---
-
---
### 메모리구조 (코드영역, 데이터영역, 힙 영역, 스택 영역)
---
-
---
### 리스트, 딕셔너리, 큐, 스택, SortedList, LinkedList
---
-
---
### AOT(Ahead Of Time compile)
---
-  
---
### JIT(Just In Time compilation)
---
- 동적 번역. 프로그램을 실행하는 시점에 컴파일하는 기법.
- 
---
### 인터프리터
---
- 런타임중, 프로그래밍 언어의 소스 코드를 읽음과 동시에 바로 코드에 대응하는 기계어를 실행하는 컴퓨터 프로그램.
  - 혹은 소스 코드를 효율적인 다른 코드로 변환하고, 이를 바로 실행함.
  - 혹은 미리 컴파일된 저장 코드의 실행을 호출함.
- 컴파일을 하지않고, 바로 시작하므로 컴파일 단계에 걸리는 시간을 단축할 수 있다.
- 하지만, 파일이 컴파일된 상태라면 컴파일된 파일을 실행시키는 것이 더 빠르다.
---
### 캐시
---
- 프로세서의 발달을 메모리의 발달이 따라가지 못함
  
- 이를 개선하기 위해 CPU안에 메모리를 내장 -> 캐시
  
- 자주 사용하는 데이터를 캐시에 담고, 해당 데이터가 필요할 때, 프로세서는 캐시에 접근하여 메모리를 받아옴.
  
- 자주 사용하는 데이터에 대한 판단은 지역성의 원리를 따름.
  - 지역성의 원리
    - **시간 지역성(Temporal locality)** : 최근 접근한 데이터에 다시 접근하는 경향.
  
    - **공간 지역성(Spatial locality)** : 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향.
  
- 캐시는 블록(Block)으로 구성되어 있으며, 블록의 개수와 크기가 캐시의 크기를 결정함.
---
#### 캐시 히트와 캐시 미스
---
- 캐시 히트
  - CPU에서 요청한 데이터가 캐시에 존재하는 경우.
    - 히트 레이턴시(Hit latency) : 히트가 발생하여 캐싱된 데이터를 가져올 때 소요되는 시간.
- 캐시 미스
  
  - CPU에서 요청한 데이터가 캐시에 존재하지 않는 경우.
    - 미스 레이턴시(Miss latency) : 미스가 발생하여 상위 캐시에서 데이터를 가져오거나(L1 캐시에 데이터가 없어서 L2 캐시에서 데이터를 찾는경우) 메모리에서 데이터를 가져올 때 소요되는 시간을 말함.
  
- 히트 레이턴시와 미스레이턴시는 캐시의 성능을 측정하는 데 중요한 요인으로 꼽힘.

- 캐시의 성능을 높이기 위한 방법
  - 캐시의 크기를 줄임 -> 히트 레이턴시가 줄어듬.
  - 캐시의 크기를 늘림 -> 미스 비율이 줄어듬.
  - 더 빠른 캐시를 이용 -> 레이턴시가 줄어듬.
---
#### L1, L2, L3 캐시
---
- L1 캐시
  - 프로세서와 가장 가까운 캐시. 속도를 위해서 Instruction Cache와 Data Cache로 나뉨.
    - Instruction Cache(I$) : 메모리의 TEXT 영역을 다루는 캐시.
    - Data Cache(D$) : TEXT 영역을 제외한 모든 데이터를 다루는 캐시.
  
- L2 캐시
  - 용량이 큰 캐시. 크기를 위해서 L1 캐시처럼 나누지 않는다.
  
- L3 캐시
  - 멀티 코어 시스템에서 여러 코어가 공유하는 캐시.
  
- Level 캐시는 하위 레벨로 갈 수록 연산이 느리고(기존 메모리보다는 빠르다.), 상위 캐시에서 캐시 미스가 발생하면 하위 캐시에서 데이터를 찾음.
---
### 컨텍스트 스위칭
---
-
---
### 콜스택
---
---
## 보안
---
-
---
### PE구조
---
---
### 커널모드와 유저모드
---
### IOCTL
---
---
### 드라이버
---
---
### 프로세스와 모듈, 스레드
---
---
## 언어
---
### C와 C++의 차이점
---
---
### C#과 C++의 차이점
---
---
### C++11/C++14/C++17 다뤄본 것
---
---
### C++ 가상함수 테이블
---
---
### C++ 스마트포인터
---
---
### C++ 캐스팅 종류와 작동방식 static_cast, dynamic_cast, interpret_cast, const_cast
---
---
### C++ stdcall과 cdecl 차이
---
---
### C++ 구조체 패딩
---
---
### C++ 이중 포인터를 이용한 이차원 동적할당과 이차원 배열과의 차이점
---
---
# 자료구조
---
## list, vector, map
---
---
### 요소 전체 순회시 가장 빠른 순서대로 나열 및 BigO 표기
---
---
### 삽입 및 삭제의 속도가 빠른 순서대로 나열 및 BigO 표기
---
---
### 랜덤 액세스가 빠른 순서대로 나열 및 BigO 표기
---
---
### 사용해야하는 상황, 하지 말아야 할 상황 구분하기
---
## 디자인패턴
---
### 싱글톤 패턴
---
---
### 옵저버 패턴
---
---
### 스트레이트지 패턴
---
---
### 팩토리 패턴
---
---
### 빌더 패턴
---
---
### 커맨드 패턴
---
---
### 브리지 패턴
---
# 그래픽스
---
## 버텍스 셰이더와 픽셀 셰이더
---
---
## 래스터라이저
---
---
## 포워드와 디퍼드 렌더링
---
---
## 디더링
---
---
## 텍스처 압축 포맷
---
---
## 드로우콜
---
---
## 오클루전 컬링과 프러스텀 컬링
---
---
## 소프트마스크
---
---
## 스텐실
---
---
## 알파테스트, 알파블렌딩
---
# 알고리즘
---
## DFS 구현 방식
---
---
## DFS와 다익스트라 차이, 장단점
---
---
## 퀵소트 버블소트
---
---
## 가장 빠른 머지소트 구현법
---
---
## 쿼드트리, 옥트리
---
---
# 네트워크
---
## TCP/UDP 차이
---
---
## 엔디언
---
- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법.
  - 바이트 순서(Byte order) : 바이트를 배열하는 방법.
    - 앞에 나오는 단위에 따라 빅 엔디언과 리틀 엔디언으로 나뉨.
  
    - 대부분의 데스크탑 컴퓨터는 리틀 엔디언을 사용함.
  
    - 반대로, 네트워크에서는 주소를 빅 엔디언을 사용함.
      - 빅 엔디언(Big-endian) : 큰 단위가 앞에 나오는 엔디언.
        - 소프트웨어의 디버그를 편하게 해주는 경향이 있다. -> 사람이 숫자를 읽는 방식과 같으므로 디버깅 과정에서 메모리의 값을 보기 편함.
  
        - 가산기의 덧셈은 마지막 바이트부터 역방향으로 진행해야함.
  
      - 리틀 엔디언(Little-endian) : 작은 단위가 앞에 나오는 엔디언.
        - 리틀 엔디언은 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없음.
  
        - 가산기의 덧셈 과정이 LSB로부터 시작하므로 가산기 설계가 단순.
  
      - 바이 엔디언 : 빅 엔디언과 리틀 엔디언 중 선택하게끔 설계된 것.
  
      - 미들 엔디언 : 빅 엔디언,리틀 엔디언 둘 다 속하지 않거나, 둘 다 지원하는 것.
---
## 패킷 컨테이너
---
---
## 소켓
---
---
## P2P, 릴레이, 데디케이트 서버
---
---
## 데드레커닝
---
---
## 락스텝
---
